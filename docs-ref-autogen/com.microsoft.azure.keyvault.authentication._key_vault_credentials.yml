### YamlMime:ManagedReference
items:
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    id: _key_vault_credentials
    parent: com.microsoft.azure.keyvault.authentication
    children:
      - com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter(OkHttpClient.Builder)
      - 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: KeyVaultCredentials
    nameWithType: KeyVaultCredentials
    fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials
    type: Class
    source:
      remote: &ref_0
        path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
        branch: bb950b2a0255c017040501de0c19e4849361ca1d
        repo: 'https://github.com/Azure/azure-keyvault-java'
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 26
    package: com.microsoft.azure.keyvault.authentication
    summary: <p>実装<xref uid="" data-throw-if-not-resolved="false">ServiceClientCredentials</xref>自動ベアラー トークンの更新をサポートします。 </p>
    syntax:
      content: public class KeyVaultCredentials
    inheritance:
      - java.lang.Object
      - ServiceClientCredentials
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter(OkHttpClient.Builder)
    id: Builder)
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    nameWithType: KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    fullName: void com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    overload: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter*
    type: Method
    source:
      remote: *ref_0
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 35
    package: com.microsoft.azure.keyvault.authentication
    syntax:
      content: public void applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
      parameters:
        - id: clientBuilder
          type: 2c0be77c
  - uid: 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    id: 'doAuthenticate(String,String,String)'
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: 'doAuthenticate(String authorization, String resource, String scope)'
    nameWithType: 'KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    fullName: 'abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    overload: com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate*
    type: Method
    source:
      remote: *ref_0
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 215
    package: com.microsoft.azure.keyvault.authentication
    summary: "<p>実装する抽象メソッドです。</p>\n<p>\n静的なプライベートの AuthenticationResult getAccessTokenFromClientCredentials (文字列承認文字列、文字列の clientId、リソース文字列 clientKey) {AuthenticationContext コンテキスト = null です。AuthenticationResult 結果 = null です。ExecutorService サービス = null です。再試行してください {サービス = Executors.newFixedThreadPool(1); コンテキスト = 新しい AuthenticationContext (承認、false の場合、サービス)ClientCredential 資格情報 = 新しい ClientCredential (clientId、clientKey) です。将来&lt;AuthenticationResult&gt;将来 = context.acquireToken (リソース、資格情報、null); 結果 = future.get();} catch (Exception e) {スロー新しい RuntimeException(e);} 最後に {service.shutdown();}</p>\n<p>場合 (結果 = = null) {スロー新しい RuntimeException (「認証の結果が null でした」);}; の結果を返す} </p>\n<p>\r\n\r\n  <b>注: クライアント キーに安全にしなければなりません。これが別のパーティによって管理されるクライアント アプリケーション 1 つは開発およびその他の運用環境用の 2 つを使用することをお勧めします。</b>\r\n\r\n</p>"
    syntax: &ref_1
      content: 'public abstract String doAuthenticate(String authorization, String resource, String scope)'
      parameters:
        - id: authorization
          type: '26831127'
          description: <p>URL は機関の識別子です。 </p>
        - id: resource
          type: '26831127'
          description: <p>URL で、要求されたトークンの受信者は、ターゲット リソースの識別子。 </p>
        - id: scope
          type: '26831127'
          description: <p>認証要求のスコープです。</p>
      return:
        type: 9065866d
        description: |-
          <p>アクセス トークン<verbatim>トークン ヘッダーを持つサーバー チャレンジに応答します。

              &lt;p&gt;

              Implementations typically use ADAL to get a token, as performed

              in the sample below:

              &lt;/p&gt;



              &lt;pre&gt;

          </verbatim>&amp;#064; オーバーライド パブリック文字列<xref uid="com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)" data-throw-if-not-resolved="false">doAuthenticate (文字列の承認、文字列リソース、文字列のスコープ)</xref> {文字列 clientId =...;//クライアント GUID Azure ポータルで示すようにします。 文字列の clientKey =... です。Azure ポータルによって提供されるようにキーをクライアントです。 AuthenticationResult トークン = getAccessTokenFromClientCredentials (承認、リソース、clientId、clientKey) です。token.getAccessToken() 以外を返します。}</p>
references:
  - uid: 2c0be77c
    spec.java:
      - name: OkHttpClient.Builder
        fullName: OkHttpClient.Builder
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter*
    name: applyCredentialsFilter
    nameWithType: KeyVaultCredentials.applyCredentialsFilter
    fullName: void com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter
    package: com.microsoft.azure.keyvault.authentication
  - uid: '26831127'
    spec.java:
      - name: String
        fullName: String
  - uid: 9065866d
    spec.java:
      - name: abstract String
        fullName: abstract String
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate*
    name: doAuthenticate
    nameWithType: KeyVaultCredentials.doAuthenticate
    fullName: abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate
    package: com.microsoft.azure.keyvault.authentication
  - uid: 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    name: 'doAuthenticate(String authorization, String resource, String scope)'
    nameWithType: 'KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    fullName: 'abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    type: Method
    summary: "<p>実装する抽象メソッドです。</p>\n<p>\n静的なプライベートの AuthenticationResult getAccessTokenFromClientCredentials (文字列承認文字列、文字列の clientId、リソース文字列 clientKey) {AuthenticationContext コンテキスト = null です。AuthenticationResult 結果 = null です。ExecutorService サービス = null です。再試行してください {サービス = Executors.newFixedThreadPool(1); コンテキスト = 新しい AuthenticationContext (承認、false の場合、サービス)ClientCredential 資格情報 = 新しい ClientCredential (clientId、clientKey) です。将来&lt;AuthenticationResult&gt;将来 = context.acquireToken (リソース、資格情報、null); 結果 = future.get();} catch (Exception e) {スロー新しい RuntimeException(e);} 最後に {service.shutdown();}</p>\n<p>場合 (結果 = = null) {スロー新しい RuntimeException (「認証の結果が null でした」);}; の結果を返す} </p>\n<p>\r\n\r\n  <b>注: クライアント キーに安全にしなければなりません。これが別のパーティによって管理されるクライアント アプリケーション 1 つは開発およびその他の運用環境用の 2 つを使用することをお勧めします。</b>\r\n\r\n</p>"
    syntax: *ref_1